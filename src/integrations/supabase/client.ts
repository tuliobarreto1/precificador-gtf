
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { v4 as uuidv4 } from 'uuid';

const SUPABASE_URL = "https://pvsjjqmsoauuxxfgdhfg.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB2c2pqcW1zb2F1dXh4ZmdkaGZnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMxMTI5NTUsImV4cCI6MjA1ODY4ODk1NX0.Mp6zyYRkHfHZTkBIkV_lpYv8nkAkJ9i7cI1y8dGGF6M";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: typeof localStorage !== 'undefined' ? localStorage : undefined,
    persistSession: true,
    autoRefreshToken: true
  }
});

// Função para verificar a conexão com o Supabase
export async function checkSupabaseConnection() {
  try {
    const { data, error } = await supabase.from('vehicle_groups').select('id').limit(1);
    
    if (error) throw error;
    
    return { success: true, data };
  } catch (error) {
    return { success: false, error };
  }
}

// Função para converter IDs de timestamp para formato UUID
const convertToValidUuid = (id: string | number): string => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (typeof id === 'string' && uuidRegex.test(id)) {
    return id;
  }
  return uuidv4();
};

// Função para salvar cliente no Supabase
export async function saveClientToSupabase(client: any) {
  try {
    const clientId = convertToValidUuid(client.id);

    const { data, error } = await supabase
      .from('clients')
      .upsert({
        id: clientId,
        name: client.name,
        document: client.document || null,
        email: client.email || null,
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      return { success: false, error };
    }

    return { success: true, data };
  } catch (error) {
    return { success: false, error };
  }
}

// Função para salvar orçamento no Supabase
export async function saveQuoteToSupabase(quote: any) {
  try {
    let userId = null;
    const adminUserStr = localStorage.getItem('admin_user');
    if (adminUserStr) {
      const adminUser = JSON.parse(adminUserStr);
      userId = adminUser.id;
    } else {
      const { data: { session } } = await supabase.auth.getSession();
      if (session?.user) {
        userId = session.user.id;
      }
    }
    
    const clientResult = await saveClientToSupabase(quote.client);
    if (!clientResult.success) {
      return { success: false, error: clientResult.error };
    }

    const isValidUuid = !!quote.id && /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(quote.id);
    const quoteId = isValidUuid ? quote.id : uuidv4();
    const clientUuid = clientResult.data.id;
    
    const quoteData = {
      id: quoteId,
      client_id: clientUuid,
      contract_months: quote.contractMonths,
      monthly_km: quote.monthlyKm,
      operation_severity: quote.operationSeverity || 3,
      has_tracking: quote.hasTracking || false,
      total_value: quote.totalCost || 0,
      status: 'active',
      title: `Orçamento ${new Date().toLocaleDateString('pt-BR')}`,
      created_by: userId
    };

    const { data, error } = await supabase
      .from('quotes')
      .upsert(quoteData)
      .select();

    if (error) {
      return { success: false, error };
    }
    
    // Se houver veículos, salvar em quote_vehicles
    if (quote.vehicles && quote.vehicles.length > 0) {
      console.log("Salvando veículos do orçamento:", quote.vehicles);
      
      // Para cada veículo, criar um registro na quote_vehicles
      for (const vehicle of quote.vehicles) {
        // Verificar se o veículo já existe no Supabase pelo número da placa
        let vehicleId = null;
        
        if (vehicle.plateNumber) {
          const { data: existingVehicles } = await supabase
            .from('vehicles')
            .select('id')
            .eq('plate_number', vehicle.plateNumber)
            .limit(1);
            
          if (existingVehicles && Array.isArray(existingVehicles) && existingVehicles.length > 0) {
            vehicleId = existingVehicles[0].id;
          }
        }
        
        // Se o veículo não existir, criar um novo
        if (!vehicleId) {
          const { data: newVehicle, error: vehicleError } = await supabase
            .from('vehicles')
            .insert({
              brand: vehicle.vehicleBrand || vehicle.brand || 'Não especificado',
              model: vehicle.vehicleModel || vehicle.model || 'Não especificado',
              year: vehicle.year || new Date().getFullYear(),
              value: vehicle.value || 0,
              plate_number: vehicle.plateNumber || null,
              is_used: vehicle.isUsed || false
            })
            .select()
            .single();
            
          if (vehicleError) {
            console.error("Erro ao salvar veículo:", vehicleError);
            continue;
          }
          
          vehicleId = newVehicle.id;
        }
        
        // Criar o registro na quote_vehicles utilizando fetch diretamente
        try {
          // Usar fetch para chamar a função RPC já que não está nos tipos
          const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/insert_quote_vehicle`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'apikey': SUPABASE_PUBLISHABLE_KEY,
              'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
            },
            body: JSON.stringify({
              p_quote_id: quoteId,
              p_vehicle_id: vehicleId,
              p_monthly_value: vehicle.monthlyValue || quote.totalCost || 0,
              p_contract_months: quote.contractMonths,
              p_monthly_km: quote.monthlyKm,
              p_operation_severity: quote.operationSeverity || 3,
              p_has_tracking: quote.hasTracking || false
            })
          });
          
          if (!response.ok) {
            throw new Error(`Erro ao inserir veículo do orçamento: ${response.statusText}`);
          }
        } catch (error) {
          console.warn('Erro ao inserir veículo do orçamento via RPC, tentando inserção direta', error);
          
          // Fallback: inserir diretamente na tabela quote_vehicles
          try {
            // Usar fetch diretamente para a tabela que não está definida nos tipos
            const response = await fetch(`${SUPABASE_URL}/rest/v1/quote_vehicles`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'apikey': SUPABASE_PUBLISHABLE_KEY,
                'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
                'Prefer': 'return=minimal'
              },
              body: JSON.stringify({
                quote_id: quoteId,
                vehicle_id: vehicleId,
                monthly_value: vehicle.monthlyValue || quote.totalCost || 0,
                contract_months: quote.contractMonths,
                monthly_km: quote.monthlyKm,
                operation_severity: quote.operationSeverity || 3,
                has_tracking: quote.hasTracking || false
              })
            });
            
            if (!response.ok) {
              throw new Error(`Erro ao inserir veículo do orçamento: ${response.statusText}`);
            }
          } catch (fallbackError) {
            console.error('Erro ao inserir veículo do orçamento:', fallbackError);
          }
        }
      }
    }
    
    return { success: true, data };
  } catch (error) {
    return { success: false, error };
  }
}

// Função para buscar orçamentos no Supabase
export async function getQuotesFromSupabase() {
  try {
    console.log("Buscando orçamentos do Supabase...");
    
    try {
      // Usar fetch para chamar a função RPC já que não está nos tipos
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_quotes_with_related_data`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_PUBLISHABLE_KEY,
          'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Erro na chamada RPC: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log("Orçamentos recuperados com sucesso via RPC:", Array.isArray(data) ? data.length : 0);
      return { success: true, quotes: Array.isArray(data) ? data : [] };
    } catch (rpcError) {
      console.error("Erro com função RPC, utilizando método alternativo:", rpcError);
      
      // Método alternativo: buscar diretamente
      const { data, error } = await supabase
        .from('quotes')
        .select(`
          *,
          client:client_id(*),
          vehicles:vehicle_id(*)
        `)
        .order('created_at', { ascending: false });
        
      if (error) {
        throw error;
      }
      
      console.log("Orçamentos recuperados via método alternativo:", Array.isArray(data) ? data.length : 0);
      return { success: true, quotes: Array.isArray(data) ? data : [] };
    }
  } catch (error) {
    console.error("Erro inesperado ao buscar orçamentos:", error);
    return { success: false, error, quotes: [] };
  }
}

// Função para buscar um único orçamento pelo ID
export async function getQuoteByIdFromSupabase(quoteId: string) {
  try {
    console.log(`Buscando orçamento com ID: ${quoteId}`);
    
    try {
      // Usar fetch para chamar a função RPC já que não está nos tipos
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_quote_by_id`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_PUBLISHABLE_KEY,
          'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
        },
        body: JSON.stringify({ p_quote_id: quoteId })
      });
      
      if (!response.ok) {
        throw new Error(`Erro na chamada RPC: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log("Orçamento recuperado com sucesso via RPC");
      return { success: true, quote: data };
    } catch (rpcError) {
      console.error("Erro com função RPC, utilizando método alternativo:", rpcError);
      
      // Fallback para o método antigo
      const { data, error } = await supabase
        .from('quotes')
        .select(`
          *,
          client:client_id(*),
          vehicles:vehicle_id(*)
        `)
        .eq('id', quoteId)
        .single();
        
      if (error) {
        console.error("Erro no fallback ao buscar orçamento por ID:", error);
        return { success: false, error };
      }
      
      console.log("Orçamento recuperado via método alternativo:", data);
      return { success: true, quote: data };
    }
  } catch (error) {
    console.error("Erro inesperado ao buscar orçamento por ID:", error);
    return { success: false, error };
  }
}

// Função para buscar veículos do Supabase
export async function getVehiclesFromSupabase() {
  try {
    const { data, error } = await supabase
      .from('vehicles')
      .select('*')
      .order('brand', { ascending: true });
    
    if (error) {
      return { success: false, error, vehicles: [] };
    }
    
    return { success: true, vehicles: data || [] };
  } catch (error) {
    return { success: false, error, vehicles: [] };
  }
}

// Função para buscar veículos de um orçamento específico
export async function getQuoteVehiclesFromSupabase(quoteId: string) {
  try {
    // Usar fetch diretamente para a tabela que não está definida nos tipos
    const response = await fetch(`${SUPABASE_URL}/rest/v1/quote_vehicles?quote_id=eq.${quoteId}&select=*,vehicle:vehicle_id(*)`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Erro ao buscar veículos do orçamento: ${response.statusText}`);
    }
    
    const data = await response.json();
    return { success: true, vehicles: Array.isArray(data) ? data : [] };
  } catch (error) {
    console.error('Erro ao buscar veículos do orçamento:', error);
    return { success: false, error, vehicles: [] };
  }
}

export const addVehicleToQuote = async (quoteId: string, vehicleData: any): Promise<{ success: boolean; data?: any; error?: any }> => {
  try {
    // Usar fetch diretamente para a tabela que não está definida nos tipos
    const response = await fetch(`${SUPABASE_URL}/rest/v1/vehicles_quotes`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
        'Prefer': 'return=representation'
      },
      body: JSON.stringify({
        quote_id: quoteId,
        vehicle_id: vehicleData.vehicle_id,
        monthly_value: vehicleData.monthly_value || 0
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('Erro ao adicionar veículo ao orçamento:', errorData);
      return { success: false, error: errorData };
    }

    const data = await response.json();
    return { success: true, data };
  } catch (error) {
    console.error('Erro inesperado ao adicionar veículo ao orçamento:', error);
    return { success: false, error };
  }
};

export const getQuoteVehicles = async (quoteId: string): Promise<{ success: boolean; vehicles?: any[]; error?: any }> => {
  try {
    // Usar fetch diretamente para a tabela que não está definida nos tipos
    const response = await fetch(`${SUPABASE_URL}/rest/v1/vehicles_quotes?quote_id=eq.${quoteId}&select=vehicle_id,monthly_value,vehicles(*)`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('Erro ao buscar veículos do orçamento:', errorData);
      return { success: false, error: errorData, vehicles: [] };
    }

    const data = await response.json();
    
    // Verifique se data é um array antes de tentar acessar sua propriedade length
    if (Array.isArray(data) && data.length > 0) {
      return { success: true, vehicles: data };
    }

    return { success: true, vehicles: [] };
  } catch (error) {
    console.error('Erro inesperado ao buscar veículos do orçamento:', error);
    return { success: false, error, vehicles: [] };
  }
};
