// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { v4 as uuidv4 } from 'uuid';

const SUPABASE_URL = "https://pvsjjqmsoauuxxfgdhfg.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB2c2pqcW1zb2F1dXh4ZmdkaGZnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMxMTI5NTUsImV4cCI6MjA1ODY4ODk1NX0.Mp6zyYRkHfHZTkBIkV_lpYv8nkAkJ9i7cI1y8dGGF6M";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: typeof localStorage !== 'undefined' ? localStorage : undefined,
    persistSession: true,
    autoRefreshToken: true
  }
});

// Função para verificar a conexão com o Supabase
export async function checkSupabaseConnection() {
  try {
    const { data, error } = await supabase.from('vehicles').select('id').limit(1);
    
    if (error) throw error;
    
    return { success: true, data };
  } catch (error) {
    return { success: false, error };
  }
}

// Função para buscar veículos do Supabase
export async function getVehiclesFromSupabase() {
  try {
    console.log("Buscando veículos do Supabase...");
    
    const { data, error } = await supabase
      .from('vehicles')
      .select('*')
      .order('brand', { ascending: true });
      
    if (error) {
      console.error("Erro ao buscar veículos:", error);
      return { success: false, error, vehicles: [] };
    }
    
    console.log(`Recuperados ${data?.length || 0} veículos com sucesso`);
    return { success: true, vehicles: data || [] };
  } catch (error) {
    console.error("Erro inesperado ao buscar veículos:", error);
    return { success: false, error, vehicles: [] };
  }
}

// Função para converter IDs de timestamp para formato UUID
const convertToValidUuid = (id: string | number): string => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (typeof id === 'string' && uuidRegex.test(id)) {
    return id;
  }
  return uuidv4();
};

// Função para salvar cliente no Supabase
export async function saveClientToSupabase(client: any) {
  try {
    const clientId = convertToValidUuid(client.id);

    const { data, error } = await supabase
      .from('clients')
      .upsert({
        id: clientId,
        name: client.name,
        document: client.document || null,
        email: client.email || null,
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      return { success: false, error };
    }

    return { success: true, data };
  } catch (error) {
    return { success: false, error };
  }
}

// Função para salvar orçamento no Supabase
export async function saveQuoteToSupabase(quote: any) {
  try {
    console.log("Iniciando salvamento de orçamento no Supabase:", quote);
    
    let userId = null;
    const adminUserStr = localStorage.getItem('admin_user');
    if (adminUserStr) {
      const adminUser = JSON.parse(adminUserStr);
      userId = adminUser.id;
    } else {
      const { data: { session } } = await supabase.auth.getSession();
      if (session?.user) {
        userId = session.user.id;
      }
    }
    
    // Salvar cliente
    const clientResult = await saveClientToSupabase(quote.client);
    if (!clientResult.success) {
      console.error("Erro ao salvar cliente:", clientResult.error);
      return { success: false, error: clientResult.error };
    }

    const isValidUuid = !!quote.id && /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(quote.id);
    const quoteId = isValidUuid ? quote.id : uuidv4();
    const clientUuid = clientResult.data.id;
    
    // Dados principais do orçamento
    const quoteData: any = {
      id: quoteId,
      client_id: clientUuid,
      contract_months: quote.contractMonths || quote.globalParams?.contractMonths || 12,
      monthly_km: quote.monthlyKm || quote.globalParams?.monthlyKm || 2000,
      operation_severity: quote.operationSeverity || quote.globalParams?.operationSeverity || 3,
      has_tracking: quote.hasTracking || quote.globalParams?.hasTracking || false,
      total_value: quote.totalCost || 0,
      status: 'active',
      title: quote.title || `Orçamento ${new Date().toLocaleDateString('pt-BR')}`,
      created_by: userId
    };
    
    console.log("Salvando orçamento com dados:", quoteData);
    
    const { data, error } = await supabase
      .from('quotes')
      .upsert(quoteData)
      .select();

    if (error) {
      console.error("Erro ao salvar orçamento:", error);
      return { success: false, error };
    }
    
    console.log("Orçamento salvo com sucesso. ID:", quoteId);
    
    // Salvar veículos associados ao orçamento
    if (quote.vehicles && quote.vehicles.length > 0) {
      console.log(`Processando ${quote.vehicles.length} veículos para salvar...`);
      
      // Primeiro, removemos quaisquer associações existentes se estiver atualizando um orçamento
      if (isValidUuid) {
        console.log("Removendo associações de veículos existentes para orçamento:", quoteId);
        const { error: deleteError } = await supabase
          .from('quote_vehicles')
          .delete()
          .eq('quote_id', quoteId);
          
        if (deleteError) {
          console.error("Erro ao remover associações de veículos existentes:", deleteError);
        }
      }
      
      // Se tivermos resultados calculados, use-os para preencher os custos dos veículos
      let quoteResults = null;
      if (quote.vehicleResults && Array.isArray(quote.vehicleResults)) {
        console.log("Usando resultados de cálculo pré-existentes:", quote.vehicleResults);
        quoteResults = quote.vehicleResults;
      } else if (quote.result && quote.result.vehicleResults) {
        console.log("Usando resultados de cálculo do objeto result:", quote.result.vehicleResults);
        quoteResults = quote.result.vehicleResults;
      }
      
      for (let i = 0; i < quote.vehicles.length; i++) {
        const vehicleItem = quote.vehicles[i];
        console.log("Processando item do veículo:", vehicleItem);
        
        // Verificar se temos um objeto de veículo válido
        let vehicle = null;
        if (vehicleItem.vehicle) {
          vehicle = vehicleItem.vehicle;
        } else if (typeof vehicleItem === 'object' && (vehicleItem.brand || vehicleItem.model)) {
          vehicle = vehicleItem;
        }
        
        if (!vehicle) {
          console.error("Veículo indefinido no item:", vehicleItem);
          continue;
        }
        
        console.log("Processando veículo:", vehicle);
        
        // Verificar se o veículo já existe no Supabase pela placa
        let vehicleId = null;
        if (vehicle.id) {
          // Se já temos um ID de veículo, verificamos se ele existe
          const { data: existingVehicleById } = await supabase
            .from('vehicles')
            .select('id')
            .eq('id', vehicle.id)
            .limit(1);
            
          if (existingVehicleById && Array.isArray(existingVehicleById) && existingVehicleById.length > 0) {
            vehicleId = existingVehicleById[0].id;
            console.log("Veículo existente encontrado pelo ID:", vehicleId);
          }
        }
        
        // Se não encontrou pelo ID, tenta pela placa
        if (!vehicleId && (vehicle.plateNumber || vehicle.plate_number)) {
          const plateToCheck = vehicle.plateNumber || vehicle.plate_number;
          console.log("Verificando se veículo já existe pela placa:", plateToCheck);
          
          const { data: existingVehicles } = await supabase
            .from('vehicles')
            .select('id')
            .eq('plate_number', plateToCheck)
            .limit(1);
            
          if (existingVehicles && Array.isArray(existingVehicles) && existingVehicles.length > 0) {
            vehicleId = existingVehicles[0].id;
            console.log("Veículo existente encontrado pela placa, ID:", vehicleId);
          }
        }
        
        // Se o veículo não existir, criar um novo
        if (!vehicleId) {
          console.log("Criando novo veículo...");
          
          const vehicleData = {
            brand: vehicle.brand || 'Não especificado',
            model: vehicle.model || 'Não especificado',
            year: vehicle.year || new Date().getFullYear(),
            value: vehicle.value || 0,
            plate_number: vehicle.plateNumber || vehicle.plate_number || null,
            is_used: vehicle.isUsed || vehicle.is_used || false,
            group_id: vehicle.groupId || vehicle.group_id || 'A', // Valor padrão para grupo
            color: vehicle.color || null,
            odometer: vehicle.odometer || 0
          };
          
          console.log("Dados do novo veículo:", vehicleData);
          
          const { data: newVehicle, error: vehicleError } = await supabase
            .from('vehicles')
            .insert(vehicleData)
            .select()
            .single();
            
          if (vehicleError) {
            console.error("Erro ao salvar veículo:", vehicleError);
            continue;
          }
          
          vehicleId = newVehicle.id;
          console.log("Novo veículo criado com ID:", vehicleId);
        }
        
        if (!vehicleId) {
          console.error("Não foi possível obter ID do veículo, pulando...");
          continue;
        }
        
        // Obter parâmetros do veículo
        let params = quote.useGlobalParams 
          ? quote.globalParams 
          : (vehicleItem.params || quote.globalParams);
        
        if (!params) {
          console.log("Parâmetros não encontrados, usando padrões");
          params = {
            contractMonths: quote.contractMonths || 12,
            monthlyKm: quote.monthlyKm || 2000,
            operationSeverity: quote.operationSeverity || 3,
            hasTracking: quote.hasTracking || false
          };
        }
        
        // Determinar valores de custos para o veículo
        let monthlyValue = 0;
        let depreciationCost = 0;
        let maintenanceCost = 0;
        let extraKmRate = 0;
        let totalCost = 0;
        
        // Buscar os resultados de cálculo para este veículo
        if (quoteResults && Array.isArray(quoteResults)) {
          const vehicleResult = quoteResults.find(r => 
            (r.vehicleId === vehicle.id) || 
            (vehicle.plateNumber && r.vehicleId === vehicle.plateNumber));
            
          if (vehicleResult) {
            console.log("Encontrado resultado de cálculo para o veículo:", vehicleResult);
            depreciationCost = vehicleResult.depreciationCost || 0;
            maintenanceCost = vehicleResult.maintenanceCost || 0;
            extraKmRate = vehicleResult.extraKmRate || 0;
            totalCost = vehicleResult.totalCost || 0;
            monthlyValue = totalCost;
          }
        }
        
        // Se não encontramos nos resultados, tente buscar nos valores individuais do veículo
        if (totalCost === 0) {
          // Primeiro, verificar se há um valor mensal específico no item do veículo
          if (vehicleItem.monthlyValue !== undefined && vehicleItem.monthlyValue !== null) {
            monthlyValue = vehicleItem.monthlyValue;
            totalCost = monthlyValue;
            console.log("Usando valor mensal específico do item do veículo:", monthlyValue);
          } 
          // Caso contrário, verificar se há um resultado calculado no veículo
          else if (vehicleItem.result && vehicleItem.result.totalCost !== undefined) {
            totalCost = vehicleItem.result.totalCost;
            monthlyValue = totalCost;
            
            // Se tivermos detalhes dos custos, use-os
            if (vehicleItem.result.depreciationCost !== undefined) {
              depreciationCost = vehicleItem.result.depreciationCost;
            }
            if (vehicleItem.result.maintenanceCost !== undefined) {
              maintenanceCost = vehicleItem.result.maintenanceCost;
            }
            if (vehicleItem.result.extraKmRate !== undefined) {
              extraKmRate = vehicleItem.result.extraKmRate;
            }
            
            console.log("Usando valor mensal do resultado calculado:", totalCost);
          }
          // Como último recurso, dividir o custo total pelo número de veículos
          else if (quote.totalCost && quote.vehicles.length > 0) {
            totalCost = quote.totalCost / quote.vehicles.length;
            monthlyValue = totalCost;
            console.log("Usando valor mensal calculado a partir do custo total:", totalCost);
          }
        }
        
        console.log("Valores de custo para o veículo:", {
          monthlyValue,
          depreciationCost,
          maintenanceCost,
          extraKmRate,
          totalCost
        });
        
        // Salvar relação veículo-orçamento na tabela quote_vehicles
        const quoteVehicleData = {
          quote_id: quoteId,
          vehicle_id: vehicleId,
          monthly_value: monthlyValue,
          monthly_km: params.monthlyKm,
          contract_months: params.contractMonths,
          operation_severity: params.operationSeverity,
          has_tracking: params.hasTracking,
          // Adicionar os novos campos de custo
          depreciation_cost: depreciationCost,
          maintenance_cost: maintenanceCost,
          extra_km_rate: extraKmRate,
          total_cost: totalCost
        };
        
        console.log("Salvando dados de quote_vehicles:", quoteVehicleData);
        
        const { data: quoteVehicleResult, error: quoteVehicleError } = await supabase
          .from('quote_vehicles')
          .insert(quoteVehicleData)
          .select();
          
        if (quoteVehicleError) {
          console.error("Erro ao associar veículo ao orçamento:", quoteVehicleError);
          continue;
        }
        
        console.log("Veículo associado com sucesso ao orçamento:", quoteVehicleResult);
      }
    } else {
      console.log("Nenhum veículo para associar ao orçamento");
    }
    
    return { success: true, data: { id: quoteId } };
  } catch (error) {
    console.error("Erro inesperado ao salvar orçamento:", error);
    return { success: false, error };
  }
}

// Função para buscar orçamentos no Supabase
export async function getQuotesFromSupabase() {
  try {
    console.log("Buscando orçamentos do Supabase...");
    
    const { data, error } = await supabase
      .from('quotes')
      .select(`
        *,
        client:client_id(*)
      `)
      .order('created_at', { ascending: false });
      
    if (error) {
      throw error;
    }
    
    // Buscar veículos para cada orçamento
    const quotes = Array.isArray(data) ? data : [];
    for (const quote of quotes) {
      const { data: vehiclesData } = await supabase
        .from('quote_vehicles')
        .select(`
          *,
          vehicle:vehicle_id(*)
        `)
        .eq('quote_id', quote.id);
        
      // Adicionar veículos ao objeto de orçamento como propriedade não-tipada
      (quote as any).vehicles = vehiclesData || [];
    }
    
    console.log("Orçamentos recuperados:", quotes.length);
    return { success: true, quotes };
  } catch (error) {
    console.error("Erro inesperado ao buscar orçamentos:", error);
    return { success: false, error, quotes: [] };
  }
}

// Função para buscar um único orçamento pelo ID
export async function getQuoteByIdFromSupabase(quoteId: string) {
  try {
    console.log(`Buscando orçamento com ID: ${quoteId}`);
    
    const { data, error } = await supabase
      .from('quotes')
      .select(`
        *,
        client:client_id(*)
      `)
      .eq('id', quoteId)
      .single();
      
    if (error) {
      console.error("Erro ao buscar orçamento por ID:", error);
      return { success: false, error };
    }
    
    // Buscar veículos associados a este orçamento
    if (data) {
      const { vehicles, success } = await getQuoteVehicles(quoteId);
      
      if (success && vehicles && Array.isArray(vehicles)) {
        (data as any).vehicles = vehicles;
        console.log(`Veículos associados ao orçamento ${quoteId}:`, vehicles);
      } else {
        (data as any).vehicles = [];
      }
      
      console.log("Orçamento recuperado:", data);
    }
    
    return { success: true, quote: data };
  } catch (error) {
    console.error("Erro inesperado ao buscar orçamento por ID:", error);
    return { success: false, error };
  }
}

export const addVehicleToQuote = async (quoteId: string, vehicleData: any): Promise<{ success: boolean; data?: any; error?: any }> => {
  try {
    // Verificar se o veículo já existe
    let vehicleId = vehicleData.vehicle_id;
    
    if (!vehicleId && vehicleData.vehicle) {
      // Se não tiver ID mas tiver objeto de veículo, verificar se já existe ou criar
      const vehicle = vehicleData.vehicle;
      
      if (vehicle.plateNumber) {
        const { data: existingVehicles } = await supabase
          .from('vehicles')
          .select('id')
          .eq('plate_number', vehicle.plateNumber)
          .limit(1);
          
        if (existingVehicles && Array.isArray(existingVehicles) && existingVehicles.length > 0) {
          vehicleId = existingVehicles[0].id;
        }
      }
      
      // Se ainda não tiver ID, criar veículo
      if (!vehicleId) {
        const { data: newVehicle, error: vehicleError } = await supabase
          .from('vehicles')
          .insert({
            brand: vehicle.brand || 'Não especificado',
            model: vehicle.model || 'Não especificado',
            year: vehicle.year || new Date().getFullYear(),
            value: vehicle.value || 0,
            plate_number: vehicle.plateNumber || null,
            is_used: vehicle.isUsed || false,
            group_id: vehicle.groupId || null
          })
          .select()
          .single();
          
        if (vehicleError) {
          console.error('Erro ao criar veículo:', vehicleError);
          return { success: false, error: vehicleError };
        }
        
        vehicleId = newVehicle.id;
      }
    }
    
    if (!vehicleId) {
      return { success: false, error: { message: 'ID do veículo não fornecido' } };
    }
    
    // Adicionar veículo ao orçamento
    const { data, error } = await supabase
      .from('quote_vehicles')
      .insert({
        quote_id: quoteId,
        vehicle_id: vehicleId,
        monthly_value: vehicleData.monthly_value || 0,
        monthly_km: vehicleData.monthly_km,
        contract_months: vehicleData.contract_months,
        operation_severity: vehicleData.operation_severity,
        has_tracking: vehicleData.has_tracking
      })
      .select();

    if (error) {
      console.error('Erro ao adicionar veículo ao orçamento:', error);
      return { success: false, error };
    }

    return { success: true, data };
  } catch (error) {
    console.error('Erro inesperado ao adicionar veículo ao orçamento:', error);
    return { success: false, error };
  }
};

// Modificar a função getQuoteVehicles para retornar mais detalhes
export const getQuoteVehicles = async (quoteId: string): Promise<{ success: boolean; vehicles?: any[]; error?: any }> => {
  try {
    console.log(`Buscando veículos para o orçamento ${quoteId}...`);
    
    const { data, error } = await supabase
      .from('quote_vehicles')
      .select(`
        id,
        quote_id,
        vehicle_id,
        monthly_value,
        monthly_km,
        contract_months,
        operation_severity,
        has_tracking,
        depreciation_cost,
        maintenance_cost,
        extra_km_rate,
        total_cost,
        vehicle:vehicle_id(*)
      `)
      .eq('quote_id', quoteId);

    if (error) {
      console.error('Erro ao buscar veículos do orçamento:', error);
      return { success: false, error, vehicles: [] };
    }
    
    const vehicles = data || [];
    console.log(`Encontrados ${vehicles.length} veículos para o orçamento ${quoteId}:`, vehicles);
    
    // Processar os veículos para garantir que todos os campos necessários estejam presentes
    const processedVehicles = vehicles.map(vehicle => {
      // Se temos um resultado de cálculo, vamos usá-lo
      const result = {
        depreciationCost: vehicle.depreciation_cost || 0,
        maintenanceCost: vehicle.maintenance_cost || 0,
        extraKmRate: vehicle.extra_km_rate || 0,
        totalCost: vehicle.total_cost || vehicle.monthly_value || 0
      };
      
      return {
        ...vehicle,
        result,
        monthly_value: vehicle.monthly_value || vehicle.total_cost || 0
      };
    });
    
    return { success: true, vehicles: processedVehicles };
  } catch (error) {
    console.error('Erro inesperado ao buscar veículos do orçamento:', error);
    return { success: false, error, vehicles: [] };
  }
};
